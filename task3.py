# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19s2jQKLFipbDX1K66G2xliqY_vN44_zH
"""

grammar = {
    "E": ["T E'"],
    "E'": ["+ T E'", ""],
    "T": ["F T'"],
    "T'": ["* F T'", ""],
    "F": ["( E )", "id"],
}


# Define the terminals and non-terminals
terminals = set(["+", "*", "(", ")", "id", "$"])
non_terminals = set(["E", "E'", "T", "T'", "F"])


# Create an LL(1) parsing table
parsing_table = {}

x = grammar['E']
y = x[0].split()
y

def compute_first(symbol):
  first_set = set()
  if symbol in terminals:
    return {symbol}

  for production in grammar[symbol]:

    if "" != production:
      split = production.split()
      first = split[0]
      first_set.update(compute_first(first))

    else:

      first_set.update("$")


  return first_set


first_dict = dict()

for key in grammar.keys():
  first_dict.update({key: compute_first(key)})

first_dict

print(first_dict)


print("Stuff")

for nont,production in grammar.items():
  print(production)

def compute_follow(symbol, first_dict):
  viable_productions = {}
  for (nont, productions) in grammar.items():
    for production in productions:
      if symbol in production.split():
        viable_productions.update({nont: {production}})

  #print(grammar)
  print(viable_productions)
  for (key,prods) in viable_productions.items():
    for prod in prods:
      chars = prod.split()
      symbol_index = chars.index(symbol)
      print(symbol_index)


compute_follow("E'", first_dict)

